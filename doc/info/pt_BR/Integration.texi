@c Language: Brazilian Portuguese, Encoding: iso-8859-1
@c /Integration.texi/1.31/Sat Jun  2 00:12:51 2007/-ko/
@menu
* Introdução a Integração::  
* Funções e Variáveis Definidas para Integração::  
* Introdução a QUADPACK::
* Funções e Variáveis Definidas para QUADPACK::
@end menu

@node Introdução a Integração, Funções e Variáveis Definidas para Integração, Integração, Integração
@section Introdução a Integração

Maxima tem muitas rotinas para manusear integração.
A função @code{integrate} faz uso de muitas dessas.  Exite também o
pacote @code{antid}, que manuseia uma função não especificada (e suas
derivadas, certamente).  Para usos numericos,
existe um conjunto de integradores adaptativos de QUADPACK,
a saber @code{quad_qag}, @code{quad_qags}, etc., os quais são descritos sob o tópico @code{QUADPACK}.
Funções hipergeométricas estão sendo trabalhadas,
veja @code{specint} para detalhes.
Geralmente falando, Maxima somente manuseia integrais que são
integráveis em termos de "funções elementares" (funções racionais,
trigonometricas, logarítmicas, exponenciais, radicais, etc.) e umas poucas
extensões (função de erro, dilogarithm).  Isso não manuseia
integrais em termos de funções desconhecidas tais como @code{g(x)} e @code{h(x)}.

@c end concepts Integration
@node Funções e Variáveis Definidas para Integração, Introdução a QUADPACK, Introdução a Integração, Integração
@section Funções e Variáveis Definidas para Integração
@c NEEDS WORK
@deffn {Função} changevar (@var{expr}, @var{f(x,y)}, @var{y}, @var{x})
Faz a mudança de variável dada por
@code{@var{f(x,y)} = 0} em todas as integrais que ocorrem em @var{expr} com integração em
relação a @var{x}.
A nova variável é @var{y}.

@c HMM, THIS EXAMPLE YIELDS A CORRECT BUT SLIGHTLY STRANGE RESULT...
@example
(%i1) assume(a > 0)$
(%i2) 'integrate (%e**sqrt(a*y), y, 0, 4);
                      4
                     /
                     [    sqrt(a) sqrt(y)
(%o2)                I  %e                dy
                     ]
                     /
                      0
(%i3) changevar (%, y-z^2/a, z, y);
                      0
                     /
                     [                abs(z)
                   2 I            z %e       dz
                     ]
                     /
                      - 2 sqrt(a)
(%o3)            - ----------------------------
                                a
@end example

Uma expressão contendo uma forma substantiva, tais como as instâncias de @code{'integrate} acima,
pode ser avaliada por @code{ev} com o sinalizador @code{nouns}.
Por exemplo, a expressão retornada por @code{changevar} acima pode ser avaliada
por @code{ev (%o3, nouns)}.

@code{changevar} pode também ser usada para alterações nos índices de uma soma ou de um
produto.  Todavia, isso deve obrigatóriamente ser realizado de forma que quando uma alteração é feita em uma
soma ou produto, essa mudança deve ser um artifício, i.e., @code{i = j+ ...}, não uma
função de grau mais alto.  E.g.,

@example
(%i4) sum (a[i]*x^(i-2), i, 0, inf);
                         inf
                         ====
                         \         i - 2
(%o4)                     >    a  x
                         /      i
                         ====
                         i = 0
(%i5) changevar (%, i-2-n, n, i);
                        inf
                        ====
                        \               n
(%o5)                    >      a      x
                        /        n + 2
                        ====
                        n = - 2
@end example

@end deffn

@c THIS ITEM IS A MESS, BUT DON'T BOTHER TO CLEAN IT UP:
@c THE GAUSS-KRONROD FUNCTIONS (QUADPACK) MAKE THIS OBSOLETE
@deffn {Função} dblint (@var{f}, @var{r}, @var{s}, @var{a}, @var{b})
Uma rotina de integral dupla que foi escrita no 
alto-nível do Maxima e então traduzida e compilada para linguagem de máquina.
Use @code{load ("dblint")} para acessar esse pacote.  Isso usa o método da regra de 
Simpson em ambas as direções x e y para calcular

@example
/b /s(x)
|  |
|  |    f(x,y) dy dx
|  |
/a /r(x)
@end example

A função @var{f} deve ser uma função traduzida ou compilada de duas
variáveis, e @var{r} e @var{s} devem cada uma ser uma função traduzida ou
compilada de uma variável, enquanto @var{a} e @var{b} devem ser números em ponto
flutuante.  A rotina tem duas variáveis globais que determinam o
número de divisões dos intervalos x e y: @code{dblint_x} e @code{dblint_y},
ambas as quais são inicialmente 10, e podem ser alteradas independentemente para
outros valores inteiros (existem @code{2*dblint_x+1} pontos calculados na
direção x , e @code{2*dblint_y+1} na direção y).
A rotina subdivide o eixo X e então para cada valor de X isso
primeiro calcula @code{@var{r}(x)} e @code{@var{s}(x)}; então o eixo Y entre @code{@var{r}(x)} e @code{@var{s}(x)} é
subdividido e a integral ao longo do eixo Y é executada usando
a regra de Simpson; então a integral ao longo do eixo X é concluída usando
a regra de Simpson com os valores da função sendo as integrais-Y.  Esse
procedimento pode ser numericamente instável por uma grande variedade razões,
mas razoávelmente rápido: evite usar isso sobre funções altamente oscilatórias
e funções com singularidades (postes ou pontos de ramificação na
região).  As integrais Y dependem de quanto fragmentados @code{@var{r}(x)} e @code{@var{s}(x)} são,
então se a ditância @code{@var{s}(x) - @var{r}(x)} varia rapidamente com X, nesse ponto pode ter
erros substanciais provenientes de truncação com diferentes saltos-tamanhos
nas várias integrais Y.  Um pode incrementar @code{dblint_x} e @code{dblint_y} em
uma tentativa para melhorar a convergência da reião, com sacrifício do
tempo de computação.  Os valores da função não são salvos, então se a
função é muito desperdiçadora de tempo,você terá de esperar por
re-computação se você mudar qualquer coisa (desculpe).
Isso é requerido que as funções @var{f}, @var{r}, e @var{s} sejam ainda traduzidas
ou compiladas previamente chamando @code{dblint}.  Isso resultará em ordens de
magnitude de melhoramentos de velocidade sobre o código interpretado em muitos casos!

@code{demo (dblint)} executa uma demonstração de @code{dblint} aplicado a um problema exemplo.
@c demo (dblint_1) FAILS WITH Could not find `fltdfnk.mc' -- DON'T BOTHER TO MENTION IT.  !!!
@c @code{demo (dblint_1)} executa outra demonstração.

@end deffn

@deffn {Função} defint (@var{expr}, @var{x}, @var{a}, @var{b})
Tenta calcular uma integral definida.
@code{defint} é chamada por @code{integrate} quando limites de integração são especificados,
i.e., quando @code{integrate} é chamado como @code{integrate (@var{expr}, @var{x}, @var{a}, @var{b})}.
Dessa forma do ponto de vista do usuário, isso é suficiente para chamar @code{integrate}.
@c SHOULD WE BOTHER TO DOCUMENT defint ??? NO FUNCTIONALITY HERE THAT IS NOT ALREADY PRESENT IN integrate !!!

@code{defint} retorna uma expressão simbólica,
e executa um dos dois: ou calcula a integral ou a forma substantiva da integral.
Veja @code{quad_qag} e funções rellacionadas para aproximação numérica de integrais definidas.

@end deffn

@c NEEDS EXPANSION AND EXAMPLES
@deffn {Função} erf (@var{x})
Representa a função de erro, cuja derivada é:
@code{2*exp(-x^2)/sqrt(%pi)}.

@end deffn

@defvr {Variável de opção} erfflag
Valor padrão: @code{true}

Quando @code{erfflag} é @code{false}, previne @code{risch} da introdução da
função @code{erf} na resposta se não houver nenhum no integrando para
começar.

@end defvr

@c NEEDS WORK
@deffn {Função} ilt (@var{expr}, @var{t}, @var{s})
Calcula a transformação inversa de Laplace de @var{expr} em
relação a @var{t} e parâmetro @var{s}.  @var{expr} deve ser uma razão de
polinômios cujo denominador tem somente fatores lineares e quadráticos.
Usando a funções @code{laplace} e @code{ilt} juntas com as funções @code{solve} ou
@code{linsolve} o usuário pode resolver uma diferencial simples ou
uma equação integral de convolução ou um conjunto delas.

@example
(%i1) 'integrate (sinh(a*x)*f(t-x), x, 0, t) + b*f(t) = t**2;
              t
             /
             [                                    2
(%o1)        I  f(t - x) sinh(a x) dx + b f(t) = t
             ]
             /
              0
(%i2) laplace (%, t, s);
                               a laplace(f(t), t, s)   2
(%o2)  b laplace(f(t), t, s) + --------------------- = --
                                       2    2           3
                                      s  - a           s
(%i3) linsolve ([%], ['laplace(f(t), t, s)]);
                                        2      2
                                     2 s  - 2 a
(%o3)     [laplace(f(t), t, s) = --------------------]
                                    5         2     3
                                 b s  + (a - a  b) s
(%i4) ilt (rhs (first (%)), s, t);
Is  a b (a b - 1)  positive, negative, or zero?

pos;
               sqrt(a b (a b - 1)) t
        2 cosh(---------------------)       2
                         b               a t
(%o4) - ----------------------------- + -------
              3  2      2               a b - 1
             a  b  - 2 a  b + a

                                                       2
                                             + ------------------
                                                3  2      2
                                               a  b  - 2 a  b + a
@end example

@end deffn

@deffn {Função} integrate (@var{expr}, @var{x})
@deffnx {Função} integrate (@var{expr}, @var{x}, @var{a}, @var{b})
Tenta símbolicamente calcular a integral de @var{expr} em relação a @var{x}.
@code{integrate (@var{expr}, @var{x})} é uma integral indefinida,
enquanto @code{integrate (@var{expr}, @var{x}, @var{a}, @var{b})} é uma integral definida,
com limites de integração @var{a} e @var{b}.
Os limites não poderam conter @var{x}, embora @code{integrate} não imponha essa restrição.
@var{a} não precisa ser menor que @var{b}.
Se @var{b} é igual a @var{a}, @code{integrate} retorna zero.

Veja @code{quad_qag} e funções relacionadas para aproximação numérica de integrais definidas.
Veja @code{residue} para computação de resíduos (integração complexa).
Veja @code{antid} para uma forma alternativa de calcular integrais indefinidas.

A integral (uma expressão livre de @code{integrate}) é retornada se @code{integrate} obtém sucesso.
De outra forma o valor de retorno é
a forma substantiva da integral (o operador com apóstrofo @code{'integrate})
ou uma expressão contendo uma ou mais formas substantivas.
A forma substantiva de @code{integrate} é mostrada com um sinal de integral.

Em algumas circunstâncias isso é útil para construir uma forma substantiva manualmente,
colocando em @code{integrate} um apóstrofo, e.g., @code{'integrate (@var{expr}, @var{x})}.
Por exemplo, a integral pode depender de alguns parâmetos que não estão ainda calculados.
A forma substantiva pode ser aplicada a seus argumentos por @code{ev (@var{i}, nouns)}
onde @var{i} é a forma substantiva de interesse.

@c BEGIN EXPOSITION ON HEURISTICS
@code{integrate} manuseia integrais definidas separadamente das indefinidas,
e utiliza uma gama de heurísticas para manusear cada caso.
Casos especiais de integrais definidas incluem limites de integração iguais a
zero ou infinito (@code{inf} ou @code{minf}),
funções trigonométricas com limites de integração iguais a zero e @code{%pi} ou @code{2 %pi},
funções racionais,
integrais relacionadas para as definições de funções @code{beta} e @code{psi},
e algumas integrais logarítmicas e trigonométricas.
Processando funções racionais pode incluir computação de resíduo.
Se um caso especial aplicável não é encontrado,
tentativa será feita para calcular a integra indefinida e avaliar isso nos limites de integração.
Isso pode incluir pegar um limite como um limite de integração tendendo ao infinito ou a menos infinito;
veja também @code{ldefint}.

Casos especiais de integrais indefinidas incluem funções trigonométricas,
exponenciais e funções logarítmicas,
e funções racionais.
@code{integrate} pode também fazer uso de uma curta tabela de integais elementares.

@code{integrate} pode realizar uma mudança de variável
se o integrando tem a forma @code{f(g(x)) * diff(g(x), x)}.
@code{integrate} tenta achar uma subexpressão @code{g(x)} de forma que
a derivada de @code{g(x)} divida o integrando.
Essa busca pode fazer uso de derivadas definidas pela função @code{gradef}.
Veja também @code{changevar} e @code{antid}.

Se nenhum dos procedimentos heurísticos acha uma integral indefinida,
o algorítmo de Risch é executado.
O sinalizador @code{risch} pode ser escolhido como um @code{evflag},
na chamada para @code{ev} ou na linha de comando,
e.g., @code{ev (integrate (@var{expr}, @var{x}), risch)} ou @code{integrate (@var{expr}, @var{x}), risch}.
Se @code{risch} está presente, @code{integrate} chama a função @code{risch}
sem tentar heurísticas primeiro.  Veja também @code{risch}.
@c END EXPOSITION ON HEURISTICS

@code{integrate} trabalha somente com relações funcionais representadas explicitamente com a notação @code{f(x)}.
@code{integrate} não respeita dependências implicitas estabelecidas pela função @code{depends}.
@code{integrate} pode necessitar conhecer alguma propriedade de um parâmetro no integrando.
@code{integrate} irá primeiro consultar a base de dados do @code{assume},
e , se a variável de interesse não está lá,
@code{integrate} perguntará ao usuário.
Dependendo da pergunta,
respostas adequadas são @code{yes;} ou @code{no;},
ou @code{pos;}, @code{zero;}, ou @code{neg;}.

@code{integrate} não é, por padrão, declarada ser linear.  Veja @code{declare} e @code{linear}.

@code{integrate} tenta integração por partes somente em uns poucos casos especiais.

Exemplos:

@itemize @bullet
@item
Integrais definidas e indefinidas elementares.

@example
(%i1) integrate (sin(x)^3, x);
                           3
                        cos (x)
(%o1)                   ------- - cos(x)
                           3
(%i2) integrate (x/ sqrt (b^2 - x^2), x);
                                 2    2
(%o2)                    - sqrt(b  - x )
(%i3) integrate (cos(x)^2 * exp(x), x, 0, %pi);
                               %pi
                           3 %e      3
(%o3)                      ------- - -
                              5      5
(%i4) integrate (x^2 * exp(-x^2), x, minf, inf);
                            sqrt(%pi)
(%o4)                       ---------
                                2
@end example

@item
Uso de @code{assume} e dúvida interativa.

@example
(%i1) assume (a > 1)$
(%i2) integrate (x**a/(x+1)**(5/2), x, 0, inf);
    2 a + 2
Is  -------  an integer?
       5

no;
Is  2 a - 3  positive, negative, or zero?

neg;
                                   3
(%o2)                  beta(a + 1, - - a)
                                   2
@end example

@item
Mudança de variável.  Existem duas mudanças de variável nesse exemplo:
uma usando a derivada estabelecida por @code{gradef},
e uma usando a derivação @code{diff(r(x))} de uma função não especificada @code{r(x)}.

@example
(%i3) gradef (q(x), sin(x**2));
(%o3)                         q(x)
(%i4) diff (log (q (r (x))), x);
                      d               2
                     (-- (r(x))) sin(r (x))
                      dx
(%o4)                ----------------------
                            q(r(x))
(%i5) integrate (%, x);
(%o5)                     log(q(r(x)))
@end example

@item
O valor de retorno contém a forma substantiva @code{'integrate}.
Nesse exemplo, Maxima pode extrair um fator do denominador
de uma função racional, mas não pode fatorar o restante ou de outra forma achar sua integral.
@code{grind} mostra a forma substantiva @code{'integrate} no resultado.
Veja também @code{integrate_use_rootsof} para mais sobre integrais de funções racionais.

@example
(%i1) expand ((x-4) * (x^3+2*x+1));
                    4      3      2
(%o1)              x  - 4 x  + 2 x  - 7 x - 4
(%i2) integrate (1/%, x);
                              /  2
                              [ x  + 4 x + 18
                              I ------------- dx
                              ]  3
                 log(x - 4)   / x  + 2 x + 1
(%o2)            ---------- - ------------------
                     73               73
(%i3) grind (%);
log(x-4)/73-('integrate((x^2+4*x+18)/(x^3+2*x+1),x))/73$
@end example

@item
Definindo uma função em termos de uma integral.
O corpo de uma função não é avaliado quando a função é definida.
Dessa forma o corpo de @code{f_1} nesse exemplo contém a forma substantiva de @code{integrate}.
O operador apóstrofo-apóstrofo @code{'@w{}'} faz com que a integral seja avaliada,
e o resultado transforme-se no corpo de @code{f_2}.

@example
(%i1) f_1 (a) := integrate (x^3, x, 1, a);
                                     3
(%o1)           f_1(a) := integrate(x , x, 1, a)
(%i2) ev (f_1 (7), nouns);
(%o2)                          600
(%i3) /* Note parentheses around integrate(...) here */
      f_2 (a) := ''(integrate (x^3, x, 1, a));
                                   4
                                  a    1
(%o3)                   f_2(a) := -- - -
                                  4    4
(%i4) f_2 (7);
(%o4)                          600
@end example
@end itemize

@end deffn

@defvr {Variável de sistema} integration_constant_counter
Valor padrão: 0

@c WHEN DOES integraçãoconstant1 SHOW UP IN THE OUTPUT OF integrate ???
@c integrate (a, x) YIELDS "a x", NOT "a x + integraçãoconstant1" !!!
@code{integração_constant_counter} é um contador que é atualizado a cada vez que uma
constante de integração (nomeada pelo Maxima, e.g., @code{integrationconstant1})
é introduzida em uma expressão pela integração indefinida de uma equação.

@end defvr

@defvr {Variável de opção} integrate_use_rootsof
Valor padrão: @code{false}

Quando @code{integrate_use_rootsof} é @code{true} e o denominador de
uma função racional não pode ser fatorado, @code{integrate} retorna a integral
em uma forma que é uma soma sobre as raízes (não conhecidas ainda) do denominador.

Por exemplo, com @code{integrate_use_rootsof} escolhido para @code{false},
@code{integrate} retorna uma integral não resolvida de uma função racional na forma substantiva:

@example
(%i1) integrate_use_rootsof: false$
(%i2) integrate (1/(1+x+x^5), x);
        /  2
        [ x  - 4 x + 5
        I ------------ dx                            2 x + 1
        ]  3    2                2            5 atan(-------)
        / x  - x  + 1       log(x  + x + 1)          sqrt(3)
(%o2)   ----------------- - --------------- + ---------------
                7                 14             7 sqrt(3)
@end example

Agora vamos escolher o sinalizador para ser true e a parte não resolvida da
integral será expressa como um somatório sobre as raízes do denominador da função racional:

@example
(%i3) integrate_use_rootsof: true$
(%i4) integrate (1/(1+x+x^5), x);
      ====        2
      \       (%r4  - 4 %r4 + 5) log(x - %r4)
       >      -------------------------------
      /                    2
      ====            3 %r4  - 2 %r4
                        3      2
      %r4 in rootsof(%r4  - %r4  + 1, %r4)
(%o4) ----------------------------------------------------------
               7

                                                             2 x + 1
                                         2            5 atan(-------)
                                    log(x  + x + 1)          sqrt(3)
                                  - --------------- + ---------------
                                          14             7 sqrt(3)
@end example

Alternativamente o usuário pode calcular as raízes do denominador separadamente,
e então expressar o integrando em termos dessas raízes,
e.g., @code{1/((x - a)*(x - b)*(x - c))} ou @code{1/((x^2 - (a+b)*x + a*b)*(x - c))}
se o denominador for um polinômio cúbico.
Algumas vezes isso ajudará Maxima a obter resultados mais úteis.

@end defvr

@c NEEDS EXAMPLES
@deffn {Função} ldefint (@var{expr}, @var{x}, @var{a}, @var{b})
Tenta calcular a integral definida de @var{expr} pelo uso de 
@code{limit} para avaliar a integral indefinida @var{expr} em relação a @var{x}
no limite superior @var{b} e no limite inferior @var{a}.
Se isso falha para calcular a integral definida,
@code{ldefint} retorna uma expressão contendo limites como formas substantivas.

@code{ldefint} não é chamada por @code{integrate},
então executando @code{ldefint (@var{expr}, @var{x}, @var{a}, @var{b})} pode retornar um resultado diferente de
@code{integrate (@var{expr}, @var{x}, @var{a}, @var{b})}.
@code{ldefint} sempre usa o mesmo método para avaliar a integral definida,
enquanto @code{integrate} pode utilizar várias heurísticas e pode reconhecer alguns casos especiais.

@end deffn

@c UMM, IS THERE SOME TEXT MISSING HERE ???
@c WHAT IS THIS ABOUT EXACTLY ??
@deffn {Função} potential (@var{givengradient})
O cálculo faz uso da variável global @code{potentialzeroloc[0]}
que deve ser @code{nonlist} ou da forma

@example
[indeterminatej=expressãoj, indeterminatek=expressãok, ...]
@end example

O
formador sendo equivalente para a expressão nonlist para todos os lados
direitos-manuseados mais tarde.  Os lados direitos indicados são usados como o
limite inferior de integração.  O sucesso das integrações pode
depender de seus valores e de sua ordem.  @code{potentialzeroloc} é inicialmente escolhido
para 0.

@end deffn

@deffn {Função} residue (@var{expr}, @var{z}, @var{z_0})
Calcula o resíduo no plano complexo da
expressão @var{expr} quando a variável @var{z} assumes o valor @var{z_0}.  O
resíduo é o coeficiente de @code{(@var{z} - @var{z_0})^(-1)} nas séries de Laurent
para @var{expr}.

@example
(%i1) residue (s/(s**2+a**2), s, a*%i);
                                1
(%o1)                           -
                                2
(%i2) residue (sin(a*x)/x**4, x, 0);
                                 3
                                a
(%o2)                         - --
                                6
@end example

@end deffn

@deffn {Função} risch (@var{expr}, @var{x})
Integra @var{expr} em relação a @var{x} usando um
caso transcendental do algorítmo de Risch.  (O caso algébrico do
algorítmo de Risch foi implementado.)  Isso atualmente
manuseia os casos de exponenciais aninhadas e logarítmos que a parte
principal de @code{integrate} não pode fazer.  @code{integrate} irá aplicar automaticamente @code{risch}
se dados esses casos.

@code{erfflag}, se @code{false}, previne @code{risch} da introdução da função
@code{erf} na resposta se não for achado nenhum no integrando para 
começar.

@example
(%i1) risch (x^2*erf(x), x);
                                                        2
             3                      2                - x
        %pi x  erf(x) + (sqrt(%pi) x  + sqrt(%pi)) %e
(%o1)   -------------------------------------------------
                              3 %pi
(%i2) diff(%, x), ratsimp;
                             2
(%o2)                       x  erf(x)
@end example

@end deffn

@c NEEDS EXPANSION, CLARIFICATION, AND EXAMPLES
@deffn {Função} tldefint (@var{expr}, @var{x}, @var{a}, @var{b})
Equivalente a @code{ldefint} com @code{tlimswitch} escolhido para @code{true}.

@end deffn

@footnotestyle end

@node Introdução a QUADPACK, Funções e Variáveis Definidas para QUADPACK, Funções e Variáveis Definidas para Integração, Integração
@section Introdução a QUADPACK


@c FOLLOWING TEXT ADAPTED WITH HEAVY MODIFICATION FROM http://www.netlib.org/slatec/src/qpdoc.f

QUADPACK é uma coleção de funções para aálculo
numérico de integrais definidas unidimensionais.
O pacote QUADPACK resultou da junção de um projeto de
R. Piessens @footnote{Applied Mathematics and Programming Division, K.U. Leuven},
E. de Doncker @footnote{Applied Mathematics and Programming Division, K.U. Leuven},
C. Ueberhuber @footnote{Institut f@"{u}r Mathematik, T.U. Wien},
e D. Kahaner @footnote{National Bureau of Standards, Washington, D.C., U.S.A}.

A biblioteca QUADPACK inclída no Maxima é uma tradução automática
(feita através do programa @code{f2cl}) do código fonte em de QUADPACK como aparece na
SLATEC Common Mathematical Library, Versão 4.1 @footnote{http://www.netlib.org/slatec}.
A biblioteca Fortran SLATEC é datada de Julho de 1993, mas as funções QUADPACK
foram escritas alguns anos antes.
Existe outra versão de QUADPACK em Netlib @footnote{http://www.netlib.org/quadpack};
não está claro no que aquela versão difere da versão existente em SLATEC.

As funções QUADPACK incluídas no Maxima são toda automáticas,
no sentido de que essas funções tentam calcular um resultado para uma precisão específica,
requerendo um número não especificado de avaliações de função.
A tradução do Lisp do Maxima da iblioteca QUADPACK também inclui algumas funç@~es não automáticas,
mas elas não são expostas a nível de Maxima.

Informação adicionalsobre a bilioteca QUADPACK pode ser encontrada no livro do QUADPACK
@footnote{R. Piessens, E. de Doncker-Kapenga, C.W. Uberhuber, e D.K. Kahaner.
@i{QUADPACK: A Subroutine Package for Automatic Integration.}
Berlin: Springer-Verlag, 1983, ISBN 0387125531.}.

@subsection Overview

@table @code
@item quad_qag
Integração de uma função genérica sobre um intervalo finito.
@code{quad_qag} implementa um integrador adaptativo globalmente simples usando a estratégia de Aind (Piessens, 1973).
O chamador pode escolher entre 6 pares de formulas da quadratura de 
Gauss-Kronrod para a componente de avaliação da regra.
As regras de alto grau são adequadas para integrandos fortemente oscilantes.

@item quad_qags
Integração de uma função genérica sob um intervalo finito.
@code{quad_qags} implementa subdivisão de intervalos globalmente adaptativos com extrapolação
(de Doncker, 1978) por meio do algorítmo de Epsilon (Wynn, 1956).

@item quad_qagi
Integração de uma função genérica  sobre um intervalo finito ou semi-finito.
O intervalo é mapeado sobre um intervalo finito e
então a mesma estratégia de @code{quad_qags} é aplicada.

@item quad_qawo
Integração de @math{cos(omega x) f(x)} ou @math{sin(omega x) f(x)} sobre um intervalo finito,
onde @math{omega} é uma constante.
A componente de avaliação da regra é baseada na técnica modificada de Clenshaw-Curtis.
@code{quad_qawo} aplica subdivisão adaptativa com extrapolação, similar a @code{quad_qags}.

@item quad_qawf
Calcula uma transformação de cosseno de Fourier ou de um seno de Fourier sobre um intervalo semi-finito.
O mesmo aproxima como @code{quad_qawo} aplicado sobre intervalos finitos sucessivos,
e aceleração de convergência por meio d algorítimo de Epsilon (Wynn, 1956) 
aplicado a séries de contribuições de integrais.

@item quad_qaws
Integraçào de @math{w(x) f(x)} sobre um intervalo finito @math{[a, b]},
onde @math{w} é uma função da forma @math{(x - a)^alpha (b - x)^beta v(x)}
e @math{v(x)} é 1 ou @math{log(x - a)} ou @math{log(b - x)} ou @math{log(x - a) log(b - x)},
e @math{alpha > -1} e @math{beta > -1}.
Auma estratégia de subdivisão adaptativa é aplicada,
com integração modificada de Clenshaw-Curtis sobre os subintervalos que possuem @math{a} ou @math{b}.

@item quad_qawc
Calcula o valor principal de Cauchy de @math{f(x)/(x - c)} sobre um intervalo finito @math{(a, b)}
e um @math{c} especificado.
A estratégia é globalmente adaptativa, e a integração
modificada de Clenshaw-Curtis é usada sobre subamplitudes
que possuírem o ponto @math{x = c}.
@end table

@node Funções e Variáveis Definidas para QUADPACK, , Introdução a QUADPACK, Integração
@section Funções e Variáveis Definidas para QUADPACK

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS
@deffn {Função} quad_qag (@var{f(x)}, @var{x}, @var{a}, @var{b}, @var{chave}, @var{epsrel}, @var{limite})
@deffnx {Função} quad_qag (@var{f}, @var{x}, @var{a}, @var{b}, @var{chave}, @var{epsrel}, @var{limite})

Integração de uma função genérica sobre um intervalo finito.
@code{quad_qag} implementa um integrador adaptativo globalmente simples usando a estratégia de Aind (Piessens, 1973).
O chamador pode escolher entre 6 pares de fórmulas da quadratura de
Gauss-Kronrod para a componente de avaliação da regra.
As regras de alto nível são adequadas para integrandos fortemente oscilatórios.

@code{quad_qag} calcula a integral

@ifhtml
@math{integrate (f(x), x, a, b)}
@end ifhtml
@ifinfo
@math{integrate (f(x), x, a, b)}
@end ifinfo
@tex
$$\int_a^b {f(x) dx}$$
@end tex

A função a ser integrada é @var{f(x)}, com variável
dependente @var{x}, e a função é para ser integrada entre os
limites @var{a} e @var{b}.  @var{chave} é o integrador a ser usado
e pode ser um inteiro entre 1 e 6, inclusive.  O valor de
@var{chave} seleciona a ordem da regra de integração de Gauss-Kronrod.
Regra de alta ordem são adequadas para integrandos fortemente oscilatórios.

O integrando pode ser especidficado como o nome de uma função Maxima ou uma função Lisp ou um operador,
uma expressão lambda do Maxima, ou uma expressão geral do Maxima.

A integração numérica é concluída adaptativamente pela subdivisão a
região de integração até que a precisão desejada for
completada.

Os argumentos opcionais @var{epsrel} e @var{limite} são o erro relativo
desejado e o número máximo de subintervalos respectivamente.
@var{epsrel} padrão em 1e-8 e @var{limite} é 200.

@code{quad_qag} retorna uma lista de quatro elementos:

@itemize
@item
uma aproximação para a integral,
@item
o erro absoluto estimado da aproximação, 
@item
o número de avaliações do integrando,
@item
um código de erro.
@end itemize

O código de erro (quarto elemento do valor de retorno) pode ter os valores:

@table @code
@item 0
se nenhum problema for encontrado; 
@item 1
se muitos subintervalos foram concluídos;
@item 2
se erro excessivo é detectado;
@item 3
se ocorre comportamento extremamente ruim do integrando;
@item 6
se a entrada é inválida.

@end table

@c NEED CROSS REFS HERE -- EITHER CROSS REF A QUADPACK OVERVIEW, OR CROSS REF EACH OF THE quad_* FUNCTIONS

Exemplos:

@example
(%i1) quad_qag (x^(1/2)*log(1/x), x, 0, 1, 3);
(%o1)    [.4444444444492108, 3.1700968502883E-9, 961, 0]
(%i2) integrate (x^(1/2)*log(1/x), x, 0, 1);
                                4
(%o2)                           -
                                9
@end example
@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS
@deffn {Função} quad_qags (@var{f(x)}, @var{x}, @var{a}, @var{b}, @var{epsrel}, @var{limite})
@deffnx {Função} quad_qags (@var{f}, @var{x}, @var{a}, @var{b}, @var{epsrel}, @var{limite})

Integração de uma função geral sobre um intervalo finito.
@code{quad_qags} implementa subdivisão de intervalo globalmente adaptativa com extrapolação
(de Doncker, 1978) através do algorítmo de (Wynn, 1956).

@code{quad_qags} computes the integral

@ifhtml
@math{integrate (f(x), x, a, b)}
@end ifhtml
@ifinfo
@math{integrate (f(x), x, a, b)}
@end ifinfo
@tex
$$\int_a^b {f(x) dx}$$
@end tex

A função a ser integrada é @var{f(x)}, com
variável dependente @var{x}, e a função é para ser integrada
entre os limites @var{a} e @var{b}.

O integrando pode ser especidficado como o nome de uma função Maxima ou uma função Lisp ou um operador,
uma expressão lambda do Maxima, ou uma expressão geral do Maxima.

Os argumentos opcionais @var{epsrel} e @var{limite} são o erro relativo
desejado e o número máximo de subintervalos, respectivamente.
@var{epsrel} padrão em 1e-8 e @var{limite} é 200.

@code{quad_qags} retorna uma lista de quatro elementos:

@itemize
@item
uma aproximação para a integral,
@item
o erro absoluto estimado da aproximação, 
@item
o número de avaliações do integrando,
@item
um código de erro.
@end itemize

O código de erro (quarto elemento do valor de retorno) pode ter os valores:

@table @code
@item 0
nenhum problema foi encontrado; 
@item 1
muitos subintervalos foram concluídos;
@item 2
erro excessivo é detectado;
@item 3
ocorreu comportamento excessivamente ruim do integrando;
@item 4
falhou para convergência
@item 5
integral é provavelmente divergente ou lentamente convergente
@item 6
se a entrada é inválida.
@end table

@c NEED CROSS REFS HERE -- EITHER CROSS REF A QUADPACK OVERVIEW, OR CROSS REF EACH OF THE quad_* FUNCTIONS

Exemplos:

@example
(%i1) quad_qags (x^(1/2)*log(1/x), x, 0 ,1);
(%o1)   [.4444444444444448, 1.11022302462516E-15, 315, 0]
@end example

Note que @code{quad_qags} é mais preciso e eficiente que @code{quad_qag} para esse integrando.

@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS
@deffn {Função} quad_qagi (@var{f(x)}, @var{x}, @var{a}, @var{inftype}, @var{epsrel}, @var{limite})
@deffnx {Função} quad_qagi (@var{f}, @var{x}, @var{a}, @var{inftype}, @var{epsrel}, @var{limite})

Integração de uma função genérica sobre um intervalo finito ou semi-finito.
O intervalo é mapeado sobre um intervalo finito e
então a mesma estratégia que em @code{quad_qags} é aplicada.

@code{quad_qagi} avalia uma das seguintes integrais

@ifhtml
@math{integrate (f(x), x, minf, inf)}
@end ifhtml
@ifinfo
@math{integrate (f(x), x, minf, inf)}
@end ifinfo
@tex
$$\int_a^\infty {f(x) dx}$$
@end tex

@ifhtml
@math{integrate (f(x), x, minf, a)}
@end ifhtml
@ifinfo
@math{integrate (f(x), x, minf, a)}
@end ifinfo
@tex
$$\int_\infty^a {f(x) dx}$$
@end tex

@ifhtml
@math{integrate (f(x), x, a, minf, inf)}
@end ifhtml
@ifinfo
@math{integrate (f(x), x, a, minf, inf)}
@end ifinfo
@tex
$$\int_{-\infty}^\infty {f(x) dx}$$
@end tex

usando a rotina Quadpack QAGI.  A função a ser integrada é
@var{f(x)}, com variável dependente @var{x}, e a função é para
ser integrada sobre um intervalo infinito.

O integrando pode ser especidficado como o nome de uma função Maxima ou uma função Lisp ou um operador,
uma expressão lambda do Maxima, ou uma expressão geral do Maxima.

O parâmetro @var{inftype} determina o intervalo de integração como segue:

@table @code
@item inf
O intervalo vai de @var{a} ao infinito positivo.
@item minf
O intervalo vai do infinito negativo até @var{a}.
@item both
O intervalo corresponde a toda reta real.
@end table

Os argumentos opcionais @var{epsrel} e @var{limite} são o erro relativo
desejado e o número maximo de subintervalos, respectivamente.
@var{epsrel} padrão para 1e-8 e @var{limite} é 200.

@code{quad_qagi} retorna uma lista de quatro elementos:

@itemize
@item
uma aproximação para a integral,
@item
o erro absoluto estimado da aproximação, 
@item
o número de avaliações do integrando,
@item
um código de erro.
@end itemize

O código de erro (quarto elemento do valor de retorno) pode ter os valores:

@table @code
@item 0
nenhum problema foi encontrado; 
@item 1
muitos subintervalos foram concluídos;
@item 2
erro excessivo é detectado;
@item 3
ocorreu comportamento excessivamente ruim do integrando;
@item 4
falhou para convergência;
@item 5
integral é provavelmente divergente ou lentamente convergente;
@item 6
se a entrada for inválida.

@end table

@c NEED CROSS REFS HERE -- EITHER CROSS REF A QUADPACK OVERVIEW, OR CROSS REF EACH OF THE quad_* FUNCTIONS

Exemplos:

@example
(%i1) quad_qagi (x^2*exp(-4*x), x, 0, inf);
(%o1)        [0.03125, 2.95916102995002E-11, 105, 0]
(%i2) integrate (x^2*exp(-4*x), x, 0, inf);
                               1
(%o2)                          --
                               32
@end example

@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS
@deffn {Função} quad_qawc (@var{f(x)}, @var{x}, @var{c}, @var{a}, @var{b}, @var{epsrel}, @var{limite})
@deffnx {Função} quad_qawc (@var{f}, @var{x}, @var{c}, @var{a}, @var{b}, @var{epsrel}, @var{limite})

Calcula o valor principal de Cauchy de @math{f(x)/(x - c)} over a finite interval.
A estratégia é globalmente adaptativa, e a integração de
Clenshaw-Curtis modificada é usada sobre as subamplitudes
que possuírem o ponto @math{x = c}.

@code{quad_qawc} calcula o valor principal de Cauchy de

@ifhtml
@math{integrate (f(x)/(x - c), x, a, b)}
@end ifhtml
@ifinfo
@math{integrate (f(x)/(x - c), x, a, b)}
@end ifinfo
@tex
$$\int_{a}^{b}{{{f\left(x\right)}\over{x-c}}\>dx}$$
@end tex

usando a rotina Quadpack QAWC.  A função a ser integrada é
@code{@var{f(x)}/(@var{x} - @var{c})}, com variável dependente @var{x}, e a função
é para ser integrada sobre o intervalo que vai de @var{a} até @var{b}.

O integrando pode ser especidficado como o nome de uma função Maxima ou uma função Lisp ou um operador,
uma expressão lambda do Maxima, ou uma expressão geral do Maxima.

Os argumentos opcionais @var{epsrel} e @var{limite} são o erro relativo
desejado e o máximo número de subintervalos, respectivamente.
@var{epsrel} padrão para 1e-8 e @var{limite} é 200.

@code{quad_qawc} retorna uma lista de quatro elementos:

@itemize
@item
uma aproximação para a integral,
@item
o erro absoluto estimado da aproximação, 
@item
o número de avaliações do integrando,
@item
um código de erro.
@end itemize

O código de erro (quarto elemento do valoor de retorno) pode ter os valores:

@table @code
@item 0
nenhum problema foi encontrado; 
@item 1
muitos subintervalos foram concluídos;
@item 2
erro excessivo é detectado;
@item 3
ocorreu comportamento excessivamente ruim do integrando;
@item 6
se a entrada é inválida.

@end table

Exemplos:

@example
(%i1) quad_qawc (2^(-5)*((x-1)^2+4^(-5))^(-1), x, 2, 0, 5);
(%o1)    [- 3.130120337415925, 1.306830140249558E-8, 495, 0]
(%i2) integrate (2^(-alpha)*(((x-1)^2 + 4^(-alpha))*(x-2))^(-1), x, 0, 5);
Principal Value
                       alpha
        alpha       9 4                 9
       4      log(------------- + -------------)
                      alpha           alpha
                  64 4      + 4   64 4      + 4
(%o2) (-----------------------------------------
                        alpha
                     2 4      + 2

         3 alpha                       3 alpha
         -------                       -------
            2            alpha/2          2          alpha/2
      2 4        atan(4 4       )   2 4        atan(4       )   alpha
    - --------------------------- - -------------------------)/2
                alpha                        alpha
             2 4      + 2                 2 4      + 2
(%i3) ev (%, alpha=5, numer);
(%o3)                    - 3.130120337415917
@end example

@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS
@deffn {Função} quad_qawf (@var{f(x)}, @var{x}, @var{a}, @var{omega}, @var{trig}, @var{epsabs}, @var{limit}, @var{maxp1}, @var{limlst})
@deffnx {Função} quad_qawf (@var{f}, @var{x}, @var{a}, @var{omega}, @var{trig}, @var{epsabs}, @var{limit}, @var{maxp1}, @var{limlst})

Calcula uma transformação de cosseno de Fourier ou de um seno de Fourier sobre um intervalo semi-finito.
usando a função QAWF do pacote Quadpack.
A mesma aproxima como em @code{quad_qawo} quando aplicada sobre intervalos finitos sucessivos,
e aceleração de convergência por meio d algorítimo de Epsilon (Wynn, 1956) 
aplicado a séries de contribuições de integrais.

@code{quad_qawf} calcula a integral

@ifhtml
@math{integrate (f(x)*w(x), x, a, inf)}
@end ifhtml
@ifinfo
@math{integrate (f(x)*w(x), x, a, inf)}
@end ifinfo
@tex
$$\int_a^\infty f(x) w(x) dx$$
@end tex

A função peso @math{w} é selecionada por @var{trig}:

@table @code
@item cos
@math{w(x) = cos (omega x)}
@item sin
@math{w(x) = sin (omega x)}
@end table

O integrando pode ser especidficado como o nome de uma função Maxima ou uma função Lisp ou um operador,
uma expressão lambda do Maxima, ou uma expressão geral do Maxima.

Os argumentos opcionais são:

@table @code
@item epsabs
Erro absoluto de aproximação desejado.  Padrão é 1d-10.
@item limit
Tamanho de array interno de trabalho.  (@var{limit} - @var{limlst})/2 é o
maximo número de subintervalos para usar.  O Padrão é 200.
@item maxp1
O número máximo dos momentos de Chebyshev.  Deve ser maior que 0.  O padrão
é 100.
@item limlst
Limite superior sobre número de ciclos.  Deve ser maior ou igual a
3.  O padrão é 10.
@end table

@c MERGE THESE LINES INTO PRECEDING TABLE
@var{epsabs} e @var{limit} são o erro relativo
desejado e o número maximo de subintervalos, respectivamente.
@var{epsrel} padrão para 1e-8 e @var{limit} é 200.

@code{quad_qawf} retorna uma lista de quatro elementos:

@itemize
@item
uma aproximação para a integral,
@item
o erro absoluto estimado da aproximação, 
@item
o número de avaliações do integrando,
@item
um código de erro.
@end itemize

O código de erro (quarto elemento do valor de retorno) pode ter os valores:

@table @code
@item 0
nenhum problema foi encontrado; 
@item 1
muitos subintervalos foram concluídos;
@item 2
erro excessivo é detectado;
@item 3
ocorreu um comportamento excessivamente ruim do integrando;
@item 6
se a entrada é invalida.

@end table

Exemplos:

@example
(%i1) quad_qawf (exp(-x^2), x, 0, 1, 'cos);
(%o1)   [.6901942235215714, 2.84846300257552E-11, 215, 0]
(%i2) integrate (exp(-x^2)*cos(x), x, 0, inf);
                          - 1/4
                        %e      sqrt(%pi)
(%o2)                   -----------------
                                2
(%i3) ev (%, numer);
(%o3)                   .6901942235215714
@end example

@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS
@deffn {Função} quad_qawo (@var{f(x)}, @var{x}, @var{a}, @var{b}, @var{omega}, @var{trig}, @var{epsabs}, @var{limite}, @var{maxp1}, @var{limlst})
@deffnx {Função} quad_qawo (@var{f}, @var{x}, @var{a}, @var{b}, @var{omega}, @var{trig}, @var{epsabs}, @var{limite}, @var{maxp1}, @var{limlst})

Integração de @math{cos(omega x) f(x)} ou @math{sin(omega x) f(x)} sobre um intervalo finito,
onde @math{omega} é uma constante.
A componente de avaliação da regra é baseada na técnica modificada de Clenshaw-Curtis.
@code{quad_qawo} aplica subdivisão adaptativa com extrapolação, similar a @code{quad_qags}.

@code{quad_qawo} calcula a integral usando a rotina
Quadpack QAWO:

@ifhtml
@math{integrate (f(x)*w(x), x, a, b)}
@end ifhtml
@ifinfo
@math{integrate (f(x)*w(x), x, a, b)}
@end ifinfo
@tex
$$\int_a^b f(x) w(x) dx$$
@end tex


A função peso @math{w} é selecionada por @var{trig}:

@table @code
@item cos
@math{w(x) = cos (omega x)}
@item sin
@math{w(x) = sin (omega x)}
@end table

O integrando pode ser especidficado como o nome de uma função Maxima ou uma função Lisp ou um operador,
uma expressão lambda do Maxima, ou uma expressão geral do Maxima.

Os argumentos opcionais são:

@table @code
@item epsabs
Erro absoluto desejado de aproximação.  O Padrão é 1d-10.
@item limite
Tamanho do array interno de trabalho.  (@var{limite} - @var{limlst})/2 é o
número máximo de subintervalos a serem usados.  Default é 200.
@item maxp1
Número máximo dos momentos de Chebyshev.  Deve ser maior que 0.  O padrão
é 100.
@item limlst
Limite superior sobre o número de ciclos.  Deve ser maior que ou igual a
3.  O padrão é 10.
@end table

@c MERGE THESE LINES INTO PRECEDING TABLE
@var{epsabs} e @var{limite} são o erro relativo
desejado e o número máximo de subintervalos, respectivamente.
@var{epsrel} o padrão é 1e-8 e @var{limite} é 200.

@code{quad_qawo} retorna uma lista de quatro elementos:

@itemize
@item
uma aproximação para a integral,
@item
o erro absoluto estimado da aproximação, 
@item
o número de avaliações do integrando,
@item
um código de erro.
@end itemize

O código de erro (quarto elemento do valor de retorno) pode ter os valores:

@table @code
@item 0
nenhum problema foi encontrado; 
@item 1
muitos subintervalos foram concluídos;
@item 2
erro excessivo é detectado;
@item 3
comportamento extremamente ruim do integrando;
@item 6
se a entrada é inválida.

@end table

Exemplos:

@example
(%i1) quad_qawo (x^(-1/2)*exp(-2^(-2)*x), x, 1d-8, 20*2^2, 1, cos);
(%o1)     [1.376043389877692, 4.72710759424899E-11, 765, 0]
(%i2) rectform (integrate (x^(-1/2)*exp(-2^(-alpha)*x) * cos(x), x, 0, inf));
                   alpha/2 - 1/2            2 alpha
        sqrt(%pi) 2              sqrt(sqrt(2        + 1) + 1)
(%o2)   -----------------------------------------------------
                               2 alpha
                         sqrt(2        + 1)
(%i3) ev (%, alpha=2, numer);
(%o3)                     1.376043390090716
@end example

@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS
@deffn {Função} quad_qaws (@var{f(x)}, @var{x}, @var{a}, @var{b}, @var{alpha}, @var{beta}, @var{wfun}, @var{epsabs}, @var{limite})
@deffnx {Função} quad_qaws (@var{f}, @var{x}, @var{a}, @var{b}, @var{alpha}, @var{beta}, @var{wfun}, @var{epsabs}, @var{limite})

Integração de @math{w(x) f(x)} sobre um intervalo finito,
onde @math{w(x)} é uma certa função algébrica ou logarítmica.
Uma estratégia de subdivisão globalmente adaptativa é aplicada,
com integração modificada de Clenshaw-Curtis sobre os subintervalos que possuírem os pontos finais
dos intervalos de integração.
 
@code{quad_qaws} calcula a integral usando a rotina
Quadpack QAWS:
 
@ifhtml
@math{integrate (f(x)*w(x), x, a, b)}
@end ifhtml
@ifinfo
@math{integrate (f(x)*w(x), x, a, b)}
@end ifinfo
@tex
$$\int_a^b f(x) w(x) dx$$
@end tex

A função peso @math{w} é selecionada por @var{wfun}:

@table @code
@item 1
@math{w(x) = (x - a)^alpha (b - x)^beta}
@item 2
@math{w(x) = (x - a)^alpha (b - x)^beta log(x - a)}
@item 3
@math{w(x) = (x - a)^alpha (b - x)^beta log(b - x)}
@item 4
@math{w(x) = (x - a)^alpha (b - x)^beta log(x - a) log(b - x)}
@end table

O integrando pode ser especidficado como o nome de uma função Maxima ou uma função Lisp ou um operador,
uma expressão lambda do Maxima, ou uma expressão geral do Maxima.

O argumentos opcionais são:

@table @code
@item epsabs
Erro absoluto desejado de aproximação.  O padrão é 1d-10.
@item limite
Tamanho do array interno de trabalho.  (@var{limite} - @var{limlst})/2 é o
número máximo de subintervalos para usar.  O padrão é 200.
@end table

@c MERGE THESE LINES INTO PRECEDING TABLE
@var{epsabs} e @var{limit} são o erro relativo
desejado e o número máximo de subintervalos, respectivamente.
@var{epsrel} o padrão é 1e-8 e @var{limite} é 200.

@code{quad_qaws} retorna uma lista de quatro elementos:

@itemize
@item
uma aproximação para a integral,
@item
o erro absoluto estimado da aproximação, 
@item
o número de avaliações do integrando,
@item
um código de erro.
@end itemize

O código de erro (quarto elemento do valor de retorno) pode ter os valores:

@table @code
@item 0
nenhum problema foi encontrado; 
@item 1
muitos subintervalos foram concluídos;
@item 2
erro excessivo é detectado;
@item 3
ocorreu um comportamento excessivamente ruim do integrando;
@item 6
se a entrada é invalida.

@end table

Exemplos:

@example
(%i1) quad_qaws (1/(x+1+2^(-4)), x, -1, 1, -0.5, -0.5, 1);
(%o1)     [8.750097361672832, 1.24321522715422E-10, 170, 0]
(%i2) integrate ((1-x*x)^(-1/2)/(x+1+2^(-alpha)), x, -1, 1);
       alpha
Is  4 2      - 1  positive, negative, or zero?

pos;
                          alpha         alpha
                   2 %pi 2      sqrt(2 2      + 1)
(%o2)              -------------------------------
                               alpha
                            4 2      + 2
(%i3) ev (%, alpha=4, numer);
(%o3)                     8.750097361672829
@end example

@end deffn


